<?xml version="1.0" encoding="utf-8"?>
<s:Window xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:mx="library://ns.adobe.com/flex/mx" width="637" height="638" minWidth="637" minHeight="638" 
		  backgroundColor="#c5c5c5"
		  creationComplete="initializeApp()">
	<s:layout>
		<s:BasicLayout/>
	</s:layout>
	<fx:Script>
		<![CDATA[
			import coordinateReference.IdentifiedCoordinate;
			import coordinateReference.IdentifiedCoordinateDic;
			
			import dataTypes.place.*;
			import dataTypes.simpleDataTypes.*;
			import dataTypes.spatialGeometry.*;
			
			import flash.filesystem.*;
			import flash.utils.Dictionary;
			
			import geoOperations.Center;
			
			import gfm.*;
			
			import instanceModel.*;
			
			import math.*;
			
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.controls.Menu;
			import mx.events.*;
			import mx.events.ListEvent;
			
			import portrayal.symbol.*;
			import portrayal.symbolStyle.*;
			
			import spark.events.IndexChangeEvent;
			
			public var kit:Kit;
			public var kitURL:String;
			public var applicationSchema:ApplicationSchema;
			
			public var accuracyWindow:AccuracyWindow;
			
			public var searchedGM:SG_Primitive;
			
			protected var featureTypes:ArrayList = new ArrayList();
			
			protected var atts:ArrayList;	// variable using for recursive process
			
			protected var baseMapFile:File = new File();
			protected var imageLocation:ImageURL = new ImageURL();
			
			protected var defaultSymbolFile:File = new File();
			protected var symbolStyles:SymbolStyleDictionary = new SymbolStyleDictionary();
			
			protected var controlPointsFile:File = new File();
			protected var controlPoints:IdentifiedCoordinateDic;
			protected var screenPoints:IdentifiedCoordinateDic  = new IdentifiedCoordinateDic();
			
			protected var pointSymbolStyle:PointSymbolStyle;
			protected var lineSymbolStyle:LineSymbolStyle;
			protected var areaSymbolStyle:AreaSymbolStyle;
			
			protected var pSym:PointSymbol;
			protected var lSym:LineSymbol;
			protected var aSym:AreaSymbol;
			protected var cross:Cross;
			protected var crossFlag:Boolean = false;
			protected var wp:SG_Point;
			
			protected var bitmap:Bitmap = new Bitmap();
			
			protected var dragFlag:Boolean    = false;
			protected var clickFlag:Boolean   = false;
			
			protected var curveStartFlag:Boolean = false;
			protected var curveEndFlag:Boolean = false;
			
			public    var geomFlag:String = "";
			protected var affineParam:AffineParam;
			protected var convertable:Boolean = false;	//possibility of the conversion from screen to ground.
			
			protected var point:SG_Point;
			protected var curve:SG_Curve;
			protected var surface:SG_Surface;
			
			protected var pointIndex:int;
			
			protected var featureSet:FeatureSet;
			protected var featureSetArray:Dictionary;
			
			protected const foundRadi:Number = 3.5;
			
			[Bindable]
			protected var attTypes:ArrayList = new ArrayList();
			
			protected var concreteType:FeatureType;
			
			[Bindable]
			protected var feature:Feature;
			
			[Bindable]
			public var features:ArrayList;
			
			[Bindable]
			public var geomAttributeList:ArrayList = new ArrayList();
			
			[Bindable]
			protected var orTitle:String = "Orientation";
			
			[Bindable]
			protected var getParamEnable:Boolean = true;
			
			public function initializeApp(): void {
				this.move(780, 150);
				
				// Basic Types
				registerClassAlias("dataTypes.simpleDataTypes.SimpleDataType", SimpleDataType);
				registerClassAlias("dataTypes.simpleDataTypes.Bool", Bool);
				registerClassAlias("dataTypes.simpleDataTypes.CharacterString", CharacterString);
				registerClassAlias("dataTypes.simpleDataTypes.Integer", Integer);
				registerClassAlias("dataTypes.simpleDataTypes.Real", Real);
				registerClassAlias("dataTypes.simpleDataTypes.Memo", Memo);
				
				
				// Location
				registerClassAlias("dataTypes.place.Address", Address);
				registerClassAlias("dataTypes.place.URL", URL);
				registerClassAlias("dataTypes.location.ImageLocation", ImageURL);
				registerClassAlias("dataTypes.location.VideoLocation", VideoURL);
				registerClassAlias("dataTypes.location.SoundLocation", SoundURL);
				
				// Geometry
				registerClassAlias("dataTypes.spatialGeometry.Coordinate2", Coordinate2);
				registerClassAlias("dataTypes.spatialGeometry.CoordinateArray", CoordinateArray);
				registerClassAlias("dataTypes.spatialGeometry.GeodeticCoordinate", GeodeticCoordinate);
				registerClassAlias("dataTypes.spatialGeometry.PlaneRectangularCoordinate", PlaneRectangularCoordinate);
				registerClassAlias("dataTypes.spatialGeometry.SG_Circle", SG_Circle);
				registerClassAlias("dataTypes.spatialGeometry.SG_Complex", SG_Complex);
				registerClassAlias("dataTypes.spatialGeometry.SG_CompositeCurve", SG_CompositeCurve);				
				registerClassAlias("dataTypes.spatialGeometry.SG_Curve", SG_Curve);				
				registerClassAlias("dataTypes.spatialGeometry.SG_Object", SG_Object);				
				registerClassAlias("dataTypes.spatialGeometry.SG_OrientableCurve", SG_OrientableCurve);
				registerClassAlias("dataTypes.spatialGeometry.SG_Point", SG_Point);
				registerClassAlias("dataTypes.spatialGeometry.SG_Primitive", SG_Primitive);
				registerClassAlias("dataTypes.spatialGeometry.SG_Rectangle", SG_Rectangle);	
				registerClassAlias("dataTypes.spatialGeometry.SG_Ring", SG_Ring);				
				registerClassAlias("dataTypes.spatialGeometry.SG_Surface", SG_Surface);
				
				// General Feature Model
				registerClassAlias("gfm.AttributeType", AttributeType);
				registerClassAlias("gfm.OperationType", OperationType);
				registerClassAlias("gfm.FeatureType", FeatureType);
				registerClassAlias("gfm.AssociationType", AssociationType);
				registerClassAlias("gfm.ApplicationSchema", ApplicationSchema);	
				registerClassAlias("gfm.ArgAttPair", ArgAttPair);
				
				// Instance Model
				registerClassAlias("instanceModel.Kit", Kit);
				registerClassAlias("instanceModel.FeatureSet", FeatureSet);
				registerClassAlias("instanceModel.Feature", Feature);
				registerClassAlias("instanceModel.AssociationSet", AssociationSet);
				registerClassAlias("instanceModel.Association", Association);
				
				
				// Symbol Styles
				registerClassAlias("portrayal.symbolStyle.PointSymbolStyle", PointSymbolStyle);
				registerClassAlias("portrayal.symbolStyle.LineSymbolStyle", LineSymbolStyle);
				registerClassAlias("portrayal.symbolStyle.AreaSymbolStyle", AreaSymbolStyle);
				registerClassAlias("portrayal.symbolStyle.CircleSymbolStyle", CircleSymbolStyle);
				registerClassAlias("portrayal.symbolStyle.SymbolStyle", SymbolStyle);
				registerClassAlias("portrayal.symbolStyle.SymbolStyleDictionary", SymbolStyleDictionary);
				
				// Symbol
				registerClassAlias("portrayal.symbol.AreaSymbol", AreaSymbol);
				registerClassAlias("portrayal.symbol.LineSymbol", LineSymbol);
				registerClassAlias("portrayal.symbol.PointSymbol", PointSymbol);
				registerClassAlias("portrayal.symbol.Circle", Circle);
				registerClassAlias("portrayal.symbol.Triangle", Triangle);
				registerClassAlias("portrayal.symbol.Cross", Cross);
				
				// Affine
				registerClassAlias("math.AffineParam", AffineParam);
				
				var pattern:RegExp = /\/\w*\.\w*/;	// regular expression to detect the file name
				
				if (kit.baseMapImageURL != null) {
					var bmURL:String = kitURL + kit.baseMapImageURL;
					baseMapImage.load(bmURL);
					baseMapImage.addEventListener(Event.RESIZE, onComplete2);
				}
				
				if (kit.affineParam != null) {
					affineParam = kit.affineParam;
					convertable = true;
					opViewStack.selectedChild = orientationView;
					orTitle = "Operable";
					getParamEnable = false;
				}
				else {
					//Alert.show("control point file is required.", "Alert", 4, this);					
					geomFlag = "control";
				}
				
				this.openDefaultSymbolFile();
			}
			
			public function openDefaultSymbolFile():void {
				// Default symbol file
				try {
					var symbolStream:FileStream = new FileStream();
					var fileURL:String = kitURL + "defaultSymbols.sym";
					var symbolFile:File = new File(fileURL);
					
					symbolStream.open(symbolFile, FileMode.READ);
					symbolStyles = symbolStream.readObject() as SymbolStyleDictionary;
					symbolStream.close();
					
					pointSymbolStyle = symbolStyles.pointSymStyles["defPoint"]	as PointSymbolStyle;
					lineSymbolStyle  = symbolStyles.lineSymStyles["defLine"] 	as LineSymbolStyle;
					areaSymbolStyle  = symbolStyles.areaSymStyles["defArea"]	as AreaSymbolStyle;
					
				}
				catch (error:IOError) {
					Alert.show("Symbol style: " + error.message, "Alert", 4, this);
					return;
				}		
			}
			
			
			protected function openButton_clickHandler(event:MouseEvent):void
			{
				// Open background image file
				try {
					baseMapFile = new File();
					var filter:FileFilter = new FileFilter("Image File", "*.png;*.jpg");
					baseMapFile.browseForOpen("Open image file", [filter]);
					baseMapFile.addEventListener(Event.SELECT, openbaseMapFile);
					baseMapFile.addEventListener(Event.CLOSE, openImageClose);
				} catch (error:IOError) {
					Alert.show(error.message);
				}
			}
			
			private function openImageClose(event:Event):void {
			}
			
			private function openbaseMapFile(event:Event):void 
			{
				//Set parameters
				baseMapFileLabel.text = baseMapFile.name;
				
				baseMapImage.load(baseMapFile.url);
				baseMapImage.addEventListener(Event.RESIZE, onComplete2);
				
				kit.baseMapImageURL = baseMapFile.name;
				
				
				
			}
			
			private function onComplete2(event:Event):void {
				// This means that image loading was completed and the image was resized, then				
				//put imageView inside center of the panel
				if (convertable) opViewStack.selectedChild = orientationView; 
				
				resetView();
			}
			
			private function resetView():void {
				var w0:Number = geometryPanel.width;
				var h0:Number = geometryPanel.height - 33;		// 33 is the size of title column
				var w1:Number = baseMapImage.width;
				var h1:Number = baseMapImage.height;
				
				var hw0:Number = h0 / w0;
				var hw1:Number = h1 / w1;
				
				var s:Number;
				
				// if horizontal ratio is larger than vertical of the panel,
				if (hw0 < hw1) 
					s = h0 / h1;
				else
					s = w0 / w1;
				
				baseMapImage.scaleX = baseMapImage.scaleY = s;
				
				baseMapImage.x = (w0 - s * w1) / 2.0;
				baseMapImage.y = (h0 - s * h1) / 2.0;	
				
				baseMapImage.content.alpha = alphaSlider.value = 1.0;
				
				workLayer.width  = baseMapImage.width;
				workLayer.height = baseMapImage.height;
				workLayer.x      = baseMapImage.x;
				workLayer.y      = baseMapImage.y;
				workLayer.scaleX = workLayer.scaleY = s;
				
				annotationLayer.width  = baseMapImage.width;
				annotationLayer.height = baseMapImage.height;
				annotationLayer.x      = baseMapImage.x;
				annotationLayer.y      = baseMapImage.y;
				annotationLayer.scaleX = annotationLayer.scaleY = s;
				
				geometrySubBox.x = geometrySubBox.y = 0;
				
				resetDrawing();
			}
			
			protected function openControlPointsButton_clickHandler(event:MouseEvent):void
			{
				// Open control points file
				try {
					controlPointsFile = new File();
					var filter:FileFilter = new FileFilter("Control Points File", "*.xml");
					controlPointsFile.addEventListener(Event.SELECT, openControlPointsFile);
					controlPointsFile.browseForOpen("Open Control Points File", [filter]);
					
				} catch (error:IOError) {
					Alert.show(error.message);
				}
				
			}
			
			private function openControlPointsFile(event:Event):void 
			{
				//Set parameters
				controlPointsLabel.text = controlPointsFile.name;
				var controlPointsStream:FileStream = new FileStream();
				controlPointsStream.open(controlPointsFile, FileMode.READ);
				var str:String = controlPointsStream.readMultiByte(controlPointsStream.bytesAvailable, "utf-8");
				try {
					var _xml:XML = XML(str);
				} catch (error:Error) {
					Alert.show(error.message);
					return;
				}
				
				controlPoints = new IdentifiedCoordinateDic();
				controlPoints.setXML(_xml);
				
				if (baseMapFileLabel.text != "") opViewStack.selectedChild = orientationView; 
				
			}			
			
			
			// SCALING, DRAGING, AND CONTROL TRANSPARENCY --------------------------
			
			private function largerButton_clickHandler(event:MouseEvent):void
			{				
				scalingAtCenter(1.25, geometryBox.width * 0.5, geometryBox.height * 0.5);				
			}
			
			private function smallerButton_clickHandler(event:MouseEvent):void
			{				
				scalingAtCenter(0.8, geometryBox.width * 0.5, geometryBox.height * 0.5);	
			}
			
			private function scalingAtCenter(s:Number, cx:Number, cy:Number):void 
			{				
				baseMapImage.scaleX = s * baseMapImage.scaleX;
				baseMapImage.scaleY = baseMapImage.scaleX;
				
				var lx:Number = cx - baseMapImage.x;
				var ly:Number = cy - baseMapImage.y;
				
				baseMapImage.x = baseMapImage.x - (s * lx - lx);
				baseMapImage.y = baseMapImage.y - (s * ly - ly);
				
				workLayer.width  = baseMapImage.width;
				workLayer.height = baseMapImage.height;
				workLayer.x = baseMapImage.x;
				workLayer.y = baseMapImage.y;
				workLayer.scaleX = workLayer.scaleY = baseMapImage.scaleX;
				
				resetDrawing();
				
				annotationLayer.width  = baseMapImage.width;
				annotationLayer.height = baseMapImage.height;
				annotationLayer.x = baseMapImage.x;
				annotationLayer.y = baseMapImage.y;
				annotationLayer.scaleX = annotationLayer.scaleY = baseMapImage.scaleX;
				
			}
			
			private function dragButton_clickHandler(event:MouseEvent):void
			{
				if (dragFlag) { 
					dragFlag = false;
					dragButton.label = "off";
					Mouse.cursor = "arrow";
					
				}
				else {
					dragFlag = true;
					dragButton.label = "on";
					Mouse.cursor = "hand";
				}
				
			}
			
			private function resetButton_clickHandler(event:MouseEvent):void
			{
				resetView();
			}
			
			private function alphaSlider_changeHandler(event:Event):void
			{
				// content means the background image
				baseMapImage.content.alpha = alphaSlider.value;
			}
			
			private function geometryPanel_mouseUpHandler(event:MouseEvent):void
			{
				if (dragFlag) {
					geometrySubBox.stopDrag();
					Mouse.cursor = "hand";
				}
			}
			
			private function geometryPanel_mouseMoveHandler(event:MouseEvent):void
			{
				var coor:Coordinate2 = new Coordinate2();
				coor.x = baseMapImage.mouseX;
				coor.y = baseMapImage.mouseY;
				
				var wp:SG_Point = searchCoincidentPoint(coor, 2.0);
				if (wp != null) {
					if (!crossFlag) {
						Mouse.hide();
						cross = new Cross(wp.position, 20);
						cross.name = "cross";
						annotationLayer.addChild(cross);
						crossFlag = true;
					}
				}
				else {
					if (crossFlag) {
						crossFlag = false;
						if (annotationLayer.getChildByName("cross") != null) {
							annotationLayer.removeChild(cross);
						}
						cross = null;
					}
					Mouse.show();
				}
			}
			
			private function geometryPanel_mouseDownHandler(event:MouseEvent):void
			{
				var coor:Coordinate2 = new Coordinate2();
				coor.x = baseMapImage.mouseX;
				coor.y = baseMapImage.mouseY;
				
				if (affineParam != null) {
					var pc:Coordinate2 = math.Affine.conversion(coor, affineParam.coefficient);
					XLabel.text = "" + pc.x.toFixed(3);
					YLabel.text = "" + pc.y.toFixed(3);
				}
				
				// IMAGE DRAGGING
				if (dragFlag) {
					geometrySubBox.startDrag(false);
					Mouse.cursor = "button";
					return;
				}
				
				// ADD GEOMETRY and controls
				switch (geomFlag) {
					case "control":
						var icrd:IdentifiedCoordinate = new IdentifiedCoordinate();
						if (opViewStack.selectedIndex == 0) return;
						if (controlIDInput.text == "") {
							Alert.show("Input the control point ID.", "Alert", 4, this);
							return;
						}
						
						icrd.id = controlIDInput.text;
						icrd.x = coor.x;
						icrd.y = coor.y;
						screenPoints.elements[icrd.id] = icrd;
						
						point = new SG_Point();
						point.position = coor;
						pSym = new PointSymbol();
						var pObj:Object = new Object();
						pObj.point = point
						pObj.style = pointSymbolStyle;
						pSym.decode(pObj);
						pSym.name = icrd.id;
						
						var wpSym:PointSymbol = workLayer.getChildByName(icrd.id) as PointSymbol;
						if (wpSym == null)　workLayer.addChild(pSym);
						else {
							workLayer.removeChild(wpSym);
							workLayer.addChild(pSym);
						}
						
						controlIDInput.text = "";
						break;
					
					case "add":
						switch (geomGroup.selectedValue) {
							case "SG_Point":
								if (pointSymbolStyle == null) {
									Alert.show("Symbol is not defined!", "Alert", 4, this);
									return;
								}
								
								point = new SG_Point();
								point.position = coor;
								kit.pointList[point.id] = point;
								
								pSym = new PointSymbol();
								pObj = new Object();
								pObj.point = point
								pObj.style = pointSymbolStyle;
								pSym.decode(pObj);
								workLayer.addChild(pSym);						
								break;
							
							case "SG_Curve":
								if (lineSymbolStyle == null) {
									Alert.show("Symbol is not defined!", "Alert", 4, this);
									return;									
								}
								
								wp = searchCoincidentPoint(coor, 2.0);
								
								if (!curveStartFlag) {
									// search the start point
									if (wp == null) {
										Alert.show("Could not find start point!", "Alert", 4, this);
										return;									
									}
									
									curveStartFlag = true;
									curve = new SG_Curve();
									curve.start = wp;
									wp.goOut.addItem(curve);
									
									curve.end = wp;
									lSym = new LineSymbol();
									var lObj:Object = new Object();
									lObj.curve = curve;
									lObj.style = lineSymbolStyle;
									lSym.decode(lObj);
									workLayer.addChild(lSym);
									return;
								}
								
								if (curveStartFlag) {
									if (wp == null) {
										// intermediate points
										var cArray:ArrayList = curve.shape;
										var cn:int = cArray.length;
										if (cn > 0) {
											var cw:Coordinate2 = cArray.getItemAt(cn - 1) as Coordinate2;
											if (math.Distance.p2p(cw, coor) == 0) return;
										}
										cArray.addItem(coor);
										curve.end = new SG_Point();
										curve.end.position = coor;
										workLayer.removeChild(lSym);
										lSym = new LineSymbol();
										lObj = new Object();
										lObj.curve = curve;
										lObj.style = lineSymbolStyle;
										lSym.decode(lObj);
										lSym.name = curve.id.toString();
										workLayer.addChild(lSym);
									}
									else {
										// end of curve
										curve.end = wp;
										wp.getIn.addItem(curve);
										
										if (curve.start == curve.end && curve.shape.length == 0) {
											Mouse.cursor = "arrow";
											Mouse.show();
											Alert.show("This is not a curve, but a point.", "Error", 4, this);
											curve.start.goOut.removeItem(curve);
											curve.end.getIn.removeItem(curve);
											
											delete kit.curveList[curve.id];	
											
											curveStartFlag = false;
											return;
										}
										
										workLayer.removeChild(lSym);
										lSym = new LineSymbol();
										lObj = new Object();
										lObj.curve = curve;
										lObj.style = lineSymbolStyle;
										lSym.decode(lObj);
										lSym.name = curve.id.toString();
										workLayer.addChild(lSym);
										
										kit.curveList[curve.id] = curve;	// add curve in the dictionary
										curveStartFlag = false;
									}
								}						
								break;
							
							case "SG_Surface":
								if (areaSymbolStyle == null) {
									Alert.show("Area symbol is not defined!", "Alert", 4, this);
									return;
								}
								
								// surface creation
								surface = findSurface(coor);
								if (surface == null) {
									Alert.show("Could not find a surface", "Alert", 4, this);
									return;
								}
								aSym = new AreaSymbol();
								var aObj:Object = new Object();
								aObj.surface = surface;
								aObj.style = areaSymbolStyle;
								aSym.decode(aObj);
								aSym.name = surface.id.toString();
								workLayer.addChild(aSym);
								
								kit.surfaceList[surface.id] = surface;	// add surface in the dictionary
								
								break;
							
						}
						break;
					
					case "search":
						searchedGM = null;
						var foundCoord:Coordinate2 = null;
						switch (geomGroup.selectedValue) {
							case "SG_Point":
								//search nearest point
								var dist:Number = Number.MAX_VALUE;
								for each (wp in kit.pointList) {
								var wd:Number = math.Distance.p2p(wp.position, coor);
								if (wd <= dist) {
									dist = wd;
									point = wp;
								}
							}
								
								if (point.featureID != "") {
									var f:Feature = kit.featureList[point.featureID];
									var fType:FeatureType = applicationSchema.featureTypes[f.typeName] as FeatureType;
									var aType:AttributeType = fType.getAttributeTypeByName(point.attributeName);
									
									if (aType.derived == "/") {
										Alert.show("Be carefull to change the position, as it is the derived attribute.", "Warning", 4, this);
									}
								}
								
								// Draw the Found Coordinate
								foundCoord = point.position;
								
								// searched geometry
								searchedGM = point;
								Mouse.show();
								
								break;
							
							case "SG_Curve":
								// search the nearest curve								
								dist = Number.MAX_VALUE;
								var nearestCoord:Coordinate2;
								for each (var wc:SG_Curve in kit.curveList) {
								var coors:CoordinateArray = new CoordinateArray();										
								coors.addItem(wc.start.position);
								coors.addAll(wc.shape);
								coors.addItem(wc.end.position);
								var nCoord:Coordinate2 = math.Relation.nearestPonLS(coor, coors);
								wd = math.Distance.p2ls(coor, coors);
								if (wd < dist) {
									dist = wd;
									nearestCoord = nCoord;
									curve = wc
								}
							}
								
								if (curve.featureID != "") {
									f = kit.featureList[curve.featureID];
									fType = applicationSchema.featureTypes[f.typeName] as FeatureType;
									aType = fType.getAttributeTypeByName(curve.attributeName);
									if (aType.derived == "/") {
										Alert.show("You should not change position, as it is derived attribute.", "Error", 4, this);
									}
								}
								
								// search the nearest vertex in the curve
								if (curve.shape.length > 0) {
									dist = Number.MAX_VALUE;
									coors = new CoordinateArray();
									coors.addAll(curve.shape);
									var n:int = coors.length;
									var nc:Coordinate2 = new Coordinate2();
									pointIndex = -1;
									for (var i:int = 0; i < n; i++) {
										var wcoor:Coordinate2 = coors.getItemAt(i) as Coordinate2;
										wd = math.Distance.p2p(nearestCoord, wcoor);
										if (wd < dist) {
											dist = wd;
											nc = wcoor;
											pointIndex = i;
										}
									}
									nearestCoord = nc;
								}
								
								// Draw Found Coord
								foundCoord = nearestCoord;
								
								//searched geometry
								searchedGM = curve;
								
								break;							
							
							case "SG_Surface":
								// search the smallest surface of which given coordinate is inside.
								var nearest:Number = Number.MAX_VALUE;
								surface = null;
								for each(var s:SG_Surface in kit.surfaceList) {
								var ring:SG_Ring = s.exterior;
								if (math.Relation.pointInRing(coor, ring)) {
									var d:Number = math.EastWest.isLSEastOfP(coor, ring.coordinateSequence());
									if (nearest > d) {
										nearest = d;
										surface = s;
										foundCoord = coor;
									}
								}
							}
								
								if (surface == null) break;
								
								if (surface.featureID != "") {
									f = kit.featureList[surface.featureID];
									fType = applicationSchema.featureTypes[f.typeName] as FeatureType;
									aType = fType.getAttributeTypeByName(surface.attributeName);
									if (aType.derived == "/") {
										Alert.show("You should not change position, as it is derived attribute.", "Error", 4, this);
									}
								}
								
								//searched geometry
								searchedGM = surface;
								
								break;
						}
						
						if (foundCoord == null) {
							if (annotationLayer.numChildren > 0) 
								annotationLayer.removeChildAt(0);
							Alert.show("No geometry is found.", "Warning", 4, this);
							return;
						}
						
						var circle:Circle = new Circle(foundCoord, foundRadi);
						circle.name = "circle";
						this.clearAnnotationLayer();
						annotationLayer.addChild(circle);	
						
						break;
					
					case "move":
						switch (geomGroup.selectedValue) {
							case "SG_Point":
								// move searched point
								circle = annotationLayer.getChildByName("circle") as Circle;
								if (circle != null) annotationLayer.removeChild(circle);
								else {
									Alert.show("Search point before move", "Alert", 4, this);
									return;
								}
								
								point.position = coor;
								kit.pointList[point.id] = point;		// move position in the point 
								
								resetDrawing();
								
								break;
							
							case "SG_Curve":
								// move a point in the searched curve
								circle = annotationLayer.getChildByName("circle") as Circle;
								if (circle != null) annotationLayer.removeChild(circle);
								else {
									Alert.show("Search point before move", "Alert", 4, this);
									return;
								}
								
								n = curve.shape.length;
								
								if (n == 0) {
									Alert.show("There is no vertex.", "Alert", 4, this);
									return;																		
								}
								
								if (pointIndex == -1) {
									Alert.show("Cannot move start position. Use point-move.", "Alert", 4, this);
									return;									
								}
								
								if (pointIndex >= 0 && pointIndex < n) {
									curve.shape.setItemAt(coor, pointIndex);	
								}
								
								if (pointIndex == n) {
									Alert.show("Cannot move end position. Use point-move.", "Alert", 4, this);
									return;									
								}
								
								resetDrawing();
								
								break;
						}
						break;
					
				}
			}
			
			// search coincident poit
			protected function searchCoincidentPoint(coor:Coordinate2, radius:Number):SG_Point {
				for each (var wp:SG_Point in kit.pointList) {
					if (math.Distance.p2p(coor, wp.position) < radius) return wp;
				}
				return null;
			}
			
			// find and construct a new surface
			protected function findSurface(coor:Coordinate2):SG_Surface {
				// find the nearest right side curve from given point
				var dist:Number = Number.MAX_VALUE;
				var nc:SG_Curve;
				var s:SG_Surface;
				
				for each (var c:SG_Curve in kit.curveList) {
					var ls:CoordinateArray = c.coordinateSeqence() as CoordinateArray;
					var d:Number = math.EastWest.isLSEastOfP(coor, ls);
					if (d > 0) {
						if (dist > d) {
							dist = d;
							nc = c;
						}
					}
				}
				
				if (nc != null) {
					s = constructExterior(coor, nc);
					if (s != null && math.Relation.pointInRing(coor, s.exterior)) {
						// search interiors
						var crvList:ArrayList = this.searchInteriorCurves(s);
						if (crvList == null) return s;
						
						s.interior = this.constructInterior(crvList, s);
						
						return s;
					}
				}
				
				// not found
				return null;
			}
			
			protected function constructInterior(crvList:ArrayList, s:SG_Surface):ArrayList {
				var rings:ArrayList = new ArrayList();
				while (crvList.length > 0) {
					var c:SG_Curve = crvList.getItemAt(0) as SG_Curve;
					var ocurve:SG_OrientableCurve = new SG_OrientableCurve();
					ocurve.original = c;
					var ring:SG_Ring = this.searchRing(ocurve);
					
					// rotation direction is oposite of exterior
					var opElements:ArrayList = new ArrayList();
					for (var i:int = ring.elements.length - 1; i >= 0; i--) {
						var ocv:SG_OrientableCurve = ring.elements.getItemAt(i) as SG_OrientableCurve;
						ocv.orientation = !ocv.orientation;
						
						if (ocv.orientation) 
							ocv.original.right = s;
						else
							ocv.original.left = s;
						
						opElements.addItem(ocv);
					}
					
					ring.elements = opElements;
					
					if (ring != null) {
						rings.addItem(ring);
						kit.ringList[ring.id] = ring;
						// store orientable curve in the list and remove original from crvList
						for (i = 0; i < ring.elements.length; i++) {
							ocv = ring.elements.getItemAt(i) as SG_OrientableCurve;
							kit.orientableCurveList[ocv.id] = ocv;
							crvList.removeItem(ocv.original);
						}
					}
				}
				return rings;
			}
			
			protected function searchInteriorCurves(_exterior:SG_Surface):ArrayList {
				var crvList:ArrayList = new ArrayList();
				for each (var c:SG_Curve in kit.curveList) {
					var coor:Coordinate2 = c.start.position;
					if (math.Relation.pointInRing(coor, _exterior.exterior)) {
						crvList.addItem(c);
					}
				}
				if (crvList.length == 0) return null;
				
				return crvList;
			}
			
			protected function constructExterior(coor:Coordinate2, nc:SG_Curve):SG_Surface {
				var ocurve:SG_OrientableCurve = new SG_OrientableCurve();
				ocurve.original = nc;
				
				var ring:SG_Ring = searchRing(ocurve);
				
				if (ring != null) {
					if (ring.rotation()) {
						// check whether a coordinate is inside or not
						var inside:Boolean = math.Relation.pointInRing(coor, ring);
						
						// if inside then create surface!
						if (inside) {
							surface = new SG_Surface();
							
							// set extend of each curve
							var n:int = ring.elements.length;
							var ocv:SG_OrientableCurve;
							for (var i:int = 0; i < n; i++) {
								ocv = ring.elements.getItemAt(i) as SG_OrientableCurve;
								ocv.original.extend.addItem(ocv);
								if (ocv.orientation) 
									ocv.original.right = surface;
								else
									ocv.original.left = surface;
							}
							surface.exterior = ring;
							kit.ringList[ring.id] = ring;
							
							// store orientable curve in the list
							for (i = 0; i < n; i++) {
								ocv = ring.elements.getItemAt(i) as SG_OrientableCurve;
								kit.orientableCurveList[ocv.id] = ocv;
							}
							
							return surface;
						}
					}
					else {
						// if outside, try oposite side 
						ocurve.orientation = false;
						ring = searchRing(ocurve);
						if (ring == null) return null;
						if (ring.rotation()) {
							// check coor is inside or not
							inside = math.Relation.pointInRing(coor, ring);
							// if inside then create surface!
							if (inside) {
								surface = new SG_Surface();
								
								// set extend of each curve						
								n = ring.elements.length;
								for (i = 0; i < n; i++) {
									ocv = ring.elements.getItemAt(i) as SG_OrientableCurve;
									ocv.original.extend.addItem(ocv);
									if (ocv.orientation) 
										ocv.original.right = surface;
									else
										ocv.original.left = surface;
								}						
								surface.exterior = ring;
								
								kit.ringList[ring.id] = ring;
								
								// store orientable curve in the list
								for (i = 0; i < n; i++) {
									ocv = ring.elements.getItemAt(i) as SG_OrientableCurve;
									kit.orientableCurveList[ocv.id] = ocv;
								}
								
								return surface;
							}
						}
					}
				}
				
				return null;
			}
			
			protected function searchRing(ocurve:SG_OrientableCurve):SG_Ring {
				var ring:SG_Ring = new SG_Ring();
				var ocurves:ArrayList = new ArrayList();	
				var woc:SG_OrientableCurve;				
				var ocStart:SG_OrientableCurve = ocurve;
				
				var startPoint:SG_Point = ocurve.startPoint();
				var endPoint:SG_Point   = ocurve.endPoint();
				
				if (startPoint.id == endPoint.id) {
					ocurves.addItem(ocurve);
					ring.elements = ocurves;
					return ring;	
				}
				
				do {
					ocurves.addItem(ocurve);	
					var pointID:String = ocurve.endPoint().id;
					var wocs:ArrayList = new ArrayList();			
					
					//select candidates
					for each (var wc:SG_Curve in kit.curveList) {
						if (wc.id != ocurve.original.id) {
							if (wc.start.id == pointID) {
								woc = new SG_OrientableCurve();
								woc.original = wc;
								woc.orientation = true;
								wocs.addItem(woc);
							}
							else if (wc.end.id == pointID) {
								woc = new SG_OrientableCurve();
								woc.original = wc;
								woc.orientation = false;
								wocs.addItem(woc);
							}
						}
					}
					
					var n:int = wocs.length;
					if (n == 0) return null;
					
					var maxBearing:Number = Number.MIN_VALUE;
					
					var cSeq:ArrayList = ocurve.coordinateSequence();
					var m:int = cSeq.length;
					// last two points
					var c0:Coordinate2 = cSeq.getItemAt(m - 2) as Coordinate2;
					var c1:Coordinate2 = cSeq.getItemAt(m - 1) as Coordinate2;
					
					for (var i:int = 0; i < n; i++) {
						woc = wocs.getItemAt(i) as SG_OrientableCurve;
						var dSeq:ArrayList = woc.coordinateSequence();
						var c2:Coordinate2 = dSeq.getItemAt(1) as Coordinate2;
						var bear:Number = math.Angle.bearing(c0, c1, c2);
						if (bear > maxBearing) {
							maxBearing = bear;
							ocurve = woc;		// next o_curve
						}	
					}
				} while (ocStart.startPoint().id != ocurve.endPoint().id);				
				ocurves.addItem(ocurve);
				
				ring.elements = ocurves;
				return ring;
			}
			
			// reset view
			protected function resetDrawing():void {
				// remove all
				var n:int = workLayer.numChildren;
				for (var i:int = 0; i < n; i++) {
					workLayer.removeChildAt(0);
				}
				
				for each (var s:SG_Surface in kit.surfaceList) {
					aSym = new AreaSymbol();
					var aObj:Object = new Object();
					aObj.surface = s;
					aObj.style = areaSymbolStyle;
					aSym.decode(aObj);
					aSym.name = s.id.toString();
					workLayer.addChild(aSym);
				}
				
				for each (var c:SG_Curve in kit.curveList) {
					lSym = new LineSymbol();
					var lObj:Object = new Object();
					lObj.curve = c;
					lObj.style = lineSymbolStyle;
					lSym.decode(lObj);
					lSym.name = c.id.toString();
					workLayer.addChild(lSym);
				}
				
				for each (var p:SG_Point in kit.pointList) {
					pSym = new PointSymbol();
					var pObj:Object = new Object();
					pObj.point = p;
					pObj.style = pointSymbolStyle;
					pSym.decode(pObj);
					pSym.name = p.id.toString();
					workLayer.addChild(pSym);
				}
				
			}
			
			protected function addGeomButton_clickHandler(event:MouseEvent):void
			{
				if (kit.affineParam == null) {
					Alert.show("Get orientation parameters before.", "Error", 4, this);
					return;
				}
				
				if (curveStartFlag) {
					Alert.show("Cannot push this button during curve digitizing.", "Alert", 4, this);
					return;					
				}
				
				geomFlag = "add";
				
				addGeomButton.alpha = 1.0;
				searchGeomButton.alpha = 0.5;
				moveGeomButton.alpha = 0.5;
				deleteGeomButton.alpha = 0.5;
				
			}
			
			
			protected function searchGeomButton_clickHandler(event:MouseEvent):void
			{
				if (kit.affineParam == null) {
					Alert.show("Get orientation parameters before.", "Error", 4, this);
					return;
				}
				
				if (curveStartFlag) {
					Alert.show("Cannot push this button during curve digitizing.", "Alert", 4, this);
					return;					
				}
				
				geomFlag = "search";
				
				addGeomButton.alpha = 0.5;
				searchGeomButton.alpha = 1.0;
				moveGeomButton.alpha = 0.5;
				deleteGeomButton.alpha = 0.5;
			}
			
			protected function moveGeomButton_clickHandler(event:MouseEvent):void
			{
				if (kit.affineParam == null) {
					Alert.show("Get orientation parameters before.", "Error", 4, this);
					return;
				}
				
				if (curveStartFlag) {
					Alert.show("Cannot push this button during curve digitizing.", "Alert", 4, this);
					return;					
				}
				
				geomFlag = "move";
				
				addGeomButton.alpha = 0.5;
				searchGeomButton.alpha = 0.5;
				moveGeomButton.alpha = 1.0;
				deleteGeomButton.alpha = 0.5;
			}
			
			protected function deleteGeomButton_clickHandler(event:MouseEvent):void
			{
				if (kit.affineParam == null) {
					Alert.show("Get orientation parameters before.", "Error", 4, this);
					return;
				}
				
				if (curveStartFlag) {
					Alert.show("Cannot push this button during curve digitizing.", "Alert", 4, this);
					return;					
				}
				
				geomFlag = "delete";
				
				addGeomButton.alpha = 0.5;
				searchGeomButton.alpha = 0.5;
				moveGeomButton.alpha = 0.5;
				deleteGeomButton.alpha = 1.0;
				
				var circle:Circle = annotationLayer.getChildByName("circle") as Circle;
				if (circle != null) annotationLayer.removeChild(circle);
				else {
					Alert.show("Search point before delete", "Alert", 4, this);
					return;
				}
				
				switch (geomGroup.selectedValue) {
					case "SG_Point":
						// delete searched point
						if (point.getIn.length > 0 || point.goOut.length > 0) {
							Alert.show("The point is not isolated.", "Alert", 4, this);
							return;									
						}
						
						if (point.featureID != "") {
							Alert.show("The point is an attribute of feature.", "Alert", 4, this);
							return;
						}
						
						pSym = workLayer.getChildByName(point.id.toString()) as PointSymbol;
						if (pSym != null) workLayer.removeChild(pSym);
						
						delete kit.pointList[point.id];	// delete position in the point 
						break;
					
					case "SG_Curve":
						// delete searched curve
						if (curve.extend.length > 0) {
							Alert.show("The curve is a boundary of surface.", "Alert", 4, this);
							return;									
						}
						
						if (curve.featureID != "") {
							Alert.show("The curve is an attribute of feature.", "Alert", 4, this);
							return;
						}
						
						lSym = workLayer.getChildByName(curve.id.toString()) as LineSymbol;
						if (lSym != null) workLayer.removeChild(lSym);
						
						curve.start.goOut.removeItem(curve);
						curve.end.getIn.removeItem(curve);
						
						delete kit.curveList[curve.id];	
						break;
					
					case "SG_Surface":
						// delete searched surface
						if (surface.featureID != "") {
							Alert.show("The surface is an attribute of feature.", "Alert", 4, this);
							return;
						}
						
						aSym = workLayer.getChildByName(surface.id.toString()) as AreaSymbol;
						if (aSym != null) workLayer.removeChild(aSym);
						
						// delete extreior
						var ring:SG_Ring = surface.exterior;
						var n:int = ring.elements.length;
						for (var i:int = 0; i < n; i++) {
							var ocv:SG_OrientableCurve = ring.elements.getItemAt(i) as SG_OrientableCurve;
							if (ocv.original.left == surface)
								ocv.original.left = null;
							if (ocv.original.right == surface)
								ocv.original.right = null;
							ocv.original.extend.removeItem(ocv);
							delete kit.orientableCurveList[ocv.id];
						}
						
						delete kit.ringList[ring.id];
						
						// delete interiors
						var inte:ArrayList = surface.interior;
						for (i = 0; i < inte.length; i++) {
							ring = inte.getItemAt(i) as SG_Ring;
							for (var j:int = 0; j < ring.elements.length; j++) {
								ocv = ring.elements.getItemAt(j) as SG_OrientableCurve;
								if (ocv.original.left == surface)
									ocv.original.left = null;
								if (ocv.original.right == surface)
									ocv.original.right = null;
								ocv.original.extend.removeItem(ocv);
								delete kit.orientableCurveList[ocv.id];
							}
							delete kit.ringList[ring.id];
						}
						
						delete kit.surfaceList[surface.id];
						
						break;
					
				}
				operationGroup.selectedValue = null;
			}
			
			public function displaySGPrimitive(_name:String, gm:SG_Primitive):Coordinate2 {
				var center:Coordinate2;
				
				searchedGM = gm;
				
				if (getQualifiedClassName(gm) == "dataTypes.spatialGeometry::SG_Point") {
					point = gm as SG_Point;
					center = point.position;
				}
				if (getQualifiedClassName(gm) == "dataTypes.spatialGeometry::SG_Curve") {
					curve = gm as SG_Curve;
					var attValue:ArrayList = new ArrayList();
					attValue.addItem(curve);
					var attValues:ArrayList = new ArrayList();
					attValues.addItem(attValue);
					var argObj:Object = new Object();
					argObj["curve"] = attValues;
					center = geoOperations.Center.centerLayingOnCurve(argObj).position;
				}
				if (getQualifiedClassName(gm) == "dataTypes.spatialGeometry::SG_Surface") {
					surface = gm as SG_Surface;
					attValue = new ArrayList();
					attValue.addItem(surface);
					attValues = new ArrayList();
					attValues.addItem(attValue);
					argObj = new Object;
					argObj["surface"] = attValues;
					center = geoOperations.Center.centerOfMIC(argObj).position;
				}
				
				// Draw the Found Circle	
				if (_name == "circle") {
					var circle:Circle = new Circle(center, foundRadi);
					circle.name = "circle";
					annotationLayer.addChild(circle);	
				}
				
				if (_name == "fromTriangle") {
					var crdArray:CoordinateArray = new CoordinateArray();
					var crd0:Coordinate2 = new Coordinate2();
					crd0.x = center.x;
					crd0.y = center.y + 5;
					crdArray.addItem(crd0);
					var crd1:Coordinate2 = new Coordinate2();
					crd1.x = center.x;
					crd1.y = center.y - 5;
					crdArray.addItem(crd1);
					var crd2:Coordinate2 = new Coordinate2();
					crd2.x = center.x + 6;
					crd2.y = center.y;
					crdArray.addItem(crd2);
					var fromTrg:Triangle = new Triangle("fromTriangle", crdArray, 0x0000ff);
					annotationLayer.addChild(fromTrg);
				}
				
				if (_name == "toTriangle") {
					crdArray = new CoordinateArray();
					crd0   = new Coordinate2();
					crd0.x = center.x;
					crd0.y = center.y + 5;
					crdArray.addItem(crd0);
					crd1   = new Coordinate2();
					crd1.x = center.x;
					crd1.y = center.y - 5;
					crdArray.addItem(crd1);
					crd2   = new Coordinate2();
					crd2.x = center.x - 6;
					crd2.y = center.y;
					
					crdArray.addItem(crd2);
					var toTrg:Triangle = new Triangle("toTriangle", crdArray, 0xff0000);
					annotationLayer.addChild(toTrg);
				}
				
				return center;
			}
			
			public function displaySGComplex(complex:SG_Complex):void {
				var point:SG_Point = new SG_Point();
				
				var argObj:Object = new Object();
				var arg:ArrayList = new ArrayList();
				arg.addItem(complex);
				var argList:ArrayList = new ArrayList();
				argList.addItem(arg);
				argObj["complex"] = argList;
				point = geoOperations.Center.centerOfComplex(argObj);
				
				// Draw the Found Circle after removing the old one						
				var circle:Circle = workLayer.getChildByName("circle") as Circle;
				if (circle != null) workLayer.removeChild(circle);
				circle = new Circle(point.position, foundRadi);
				circle.name = "circle";
				annotationLayer.addChild(circle);	
			}
			
			public function clearAnnotationLayer():void {
				var m:int = annotationLayer.numChildren;
				if (m > 0) {
					for (var i:int = 0; i < m; i++) {
						annotationLayer.removeChildAt(0);
					}
				}
			}
			
			protected function getParamButton_clickHandler(event:MouseEvent):void
			{
				if (geomFlag == "control") {
					var x:Array = new Array();
					var X:Array = new Array();
					
					var icrd:IdentifiedCoordinate;
					var i:int = 0;
					for each (icrd in screenPoints.elements) {
						x[i] = new Array();		// screen point
						x[i][0] = icrd.x;
						x[i][1] = icrd.y;
						x[i][2] = 1;
						var jcrd:IdentifiedCoordinate = controlPoints.elements[icrd.id];
						if (jcrd == null) {
							Alert.show("There is no point having same id. Try again from first. id:" + icrd.id, "Alert", 4, this);
							
							// eliminate control points from the screen
							for each(icrd in screenPoints.elements) {
								pSym = workLayer.getChildByName(icrd.id) as PointSymbol;
								workLayer.removeChild(pSym);					
							}
							
							screenPoints = new IdentifiedCoordinateDic();
							return;
						}
						
						X[i] = new Array();		// ground point
						X[i][0] = jcrd.x;
						X[i][1] = jcrd.y;
						
						i++;
					}
					
					affineParam = math.Affine.getParameters(X, x);
					i = 0;
					for each(icrd in screenPoints.elements) {
						affineParam.ids[i++] = icrd.id;	
					}
					
					kit.affineParam = affineParam;
					
					geomFlag = "";
					
					// eliminate control points from the screen
					for each(icrd in screenPoints.elements) {
						pSym = workLayer.getChildByName(icrd.id) as PointSymbol;
						workLayer.removeChild(pSym);					
					}
					
					// open accuracy window
					accuracyWindow = new AccuracyWindow();
					accuracyWindow.ap = affineParam;
					accuracyWindow.open();
					accuracyWindow.addEventListener(Event.CLOSE, accuracyWindowClose);
					return;
				}
				
			}
			
			protected function accuracyWindowClose(event:Event):void {
				if (accuracyWindow.isAccepted) {
					convertable = true;
					orTitle = "Operable";
					getParamEnable = false;
				}
				else if (accuracyWindow.isRejected) {
					var scp:IdentifiedCoordinate;
					for each (scp in screenPoints) {
						workLayer.removeChild(workLayer.getChildByName(scp.id));
					}
					convertable = false;
					geomFlag = "control";
					getParamEnable = true;
				}
				accuracyWindow = null;
				
			}
			
			
			protected function qualityButton_clickHandler(event:MouseEvent):void
			{
				if (kit.affineParam == null) {
					Alert.show("Get parameters before.", "Error", 4, this);
					return;
				}
				
				accuracyWindow = new AccuracyWindow();
				accuracyWindow.ap = kit.affineParam;
				affineParam = kit.affineParam;
				accuracyWindow.open();
				accuracyWindow.addEventListener(Event.CLOSE, accuracyWindowClose);
			}
			
			public function showAssociation(association:Association):void
			{
				if (association.relateFrom.length == 0 && association.relateTo.length == 0) {
					Alert.show("Alert", "Select at least from or to before.", 4, this);
					return;
				}
				
				// from geometry
				this.clearAnnotationLayer();
				var assoType:AssociationType = applicationSchema.associationTypes[association.typeName] as AssociationType;
				
				var pxName:String = assoType.from.proxyName;
				var attType:AttributeType = assoType.from.getAttributeTypeByName(pxName);
				
				if (attType != null) {
					var dt:String = attType.dataType;
					if (dt == "SG_Point" || dt == "SG_Curve" || dt == "SG_Surface") {
						var fromFeatures:ArrayList = association.relateFrom;	// instances
						for (var i:int = 0; i < fromFeatures.length; i++) {
							var fromFeature:Feature = fromFeatures.getItemAt(i) as Feature;
							var primiList:ArrayList   = fromFeature.attributes[attType.name] as ArrayList;
							for (var j:int = 0; j < primiList.length; j++) {
								this.displaySGPrimitive("fromTriangle", primiList.getItemAt(j) as SG_Primitive);
							}
						}
					}					
				}
				
				pxName = assoType.to.proxyName;
				attType = assoType.to.getAttributeTypeByName(pxName);
				
				if (attType != null) {
					dt = attType.dataType;
					if (dt == "SG_Point" || dt == "SG_Curve" || dt == "SG_Surface") {
						var toFeatures:ArrayList = association.relateTo;		// instances
						for (i = 0; i < toFeatures.length; i++) {
							var toFeature:Feature = toFeatures.getItemAt(i) as Feature;
							primiList = toFeature.attributes[attType.name] as ArrayList;
							for (j = 0; j < primiList.length; j++) {
								this.displaySGPrimitive("toTriangle", primiList.getItemAt(j) as SG_Primitive);
							}
						}
					}
				}
				
				/* display association by connecting lines
				if (attTypeFrom != null) {
				var fromFeatures:ArrayList = association.relateFrom;	// instances
				for (var i:int = 0; i < fromFeatures.length; i++) {
				var fromFeature:Feature = fromFeatures.getItemAt(i) as Feature;
				var primiList:ArrayList   = fromFeature.attributes[attTypeFrom.name] as ArrayList;
				var start:Coordinate2 = this.displaySGPrimitive("fromTriangle", primiList.getItemAt(0) as SG_Primitive);
				
				// to geometries
				var attTypeTo:AttributeType = assoType.to.proxy;
				if (attTypeTo != null) {
				var toFeatures:ArrayList = association.relateTo;		// instances
				for (var j:int = 0; j < toFeatures.length; j++) {
				var toFeature:Feature = toFeatures.getItemAt(j) as Feature;
				primiList = toFeature.attributes[attTypeTo.name] as ArrayList;
				var end:Coordinate2 = this.displaySGPrimitive("toTriangle", primiList.getItemAt(0) as SG_Primitive);
				var name:String = "line:" + association.id + ":" + fromFeature.id + ":" + toFeature.id;
				this.displayLine(name, start, end);
				}
				}
				}
				}
				*/
				
			}
			
			// Text and instruction  Controls
			protected function text_jp_clickHandler(event:MouseEvent):void
			{
				var request:URLRequest = new URLRequest("documents/jp/geometryAndAssociation_jp.html");
				navigateToURL(request);
			}
			
			protected function text_en_clickHandler(event:MouseEvent):void
			{
				var request:URLRequest = new URLRequest("documents/en/geometryAndAssociation_en.html");
				navigateToURL(request);
			}
			
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<s:RadioButtonGroup id="geomGroup"/>
		<s:RadioButtonGroup id="operationGroup"/>
		
		<!-- 非ビジュアルエレメント (サービス、値オブジェクトなど) をここに配置 -->
	</fx:Declarations>
	<mx:Image x="10" y="10" source="@Embed('images/pictAcquisition1.png')" width="50" height="50"/>
	<s:Label x="75" y="15" text="Geometry" fontSize="16"/>
	<!--
	<s:TabBar id="opTab" dataProvider="{opViewStack}" x="32" y="81" height="20"/> 	
	-->
	<mx:ViewStack id="opViewStack" borderStyle="solid" width="500" height="77" x="23" y="83"> 		
		<s:NavigatorContent id="preparationView" label="Preparation" backgroundColor="#fefee5"> 
			<s:Group width="100%" height="100%" x="0" y="0">
				<s:Label x="15" y="15" fontSize="16" fontWeight="bold" text="Preparation"/>
				<s:Label x="194" y="18" text="Base Map" width="84" height="12"/>
				<s:Label x="133" y="42" id="baseMapFileLabel" backgroundColor="#DADADA" width="145" height="20" verticalAlign="middle"/>
				<s:Button x="134" y="12" label="open" width="50" id="openButton" click="openButton_clickHandler(event)" />
				
				<s:Label id="controlPointsLabel" x="288" y="42" width="145" height="20"
						 backgroundColor="#DADADA" verticalAlign="middle"/>
				<s:Button x="290" y="12" label="open" width="51" id="openControlPointsButton" click="openControlPointsButton_clickHandler(event)"/>
				<s:Label id="controlPointTitle" x="350" y="15" width="83" height="20"
						 text="Control Points" verticalAlign="middle"/>
			</s:Group>
		</s:NavigatorContent>
		
		<s:NavigatorContent id="orientationView" label="Orientation" backgroundColor="#fefee5"> 
			<s:Group width="500" height="100%" x="0" y="0">
				<s:Label id="orientationLabel" x="15" y="15" text="{orTitle}" fontSize="16"/>
				<s:Label x="104" y="38" text="Control Point ID"/>
				<s:Rect x="369" y="9" width="120" height="60">
					<s:fill>
						<s:SolidColor color="#dadada"/>
					</s:fill>
				</s:Rect>
				<s:TextInput x="193" y="31" width="76" id="controlIDInput"/>
				<s:Button x="373" y="15" label="get parameters »" id="getParamButton" chromeColor="#dadada" 
						  click="getParamButton_clickHandler(event)" enabled="{getParamEnable}"/>
				<s:Button id="qualityButton" x="373" y="42" width="111" label=" show quality »"
						  click="qualityButton_clickHandler(event)"/>
				
			</s:Group>
		</s:NavigatorContent> 		
	</mx:ViewStack> 	
	
	<s:Panel id="geometryPanel" left="21" right="112" top="168" bottom="38" chromeColor="#444444"
			 dropShadowVisible="false" title="Geometry Editing Panel" color="#ffffff">
		<s:Button id="resetButton" x="460" y="-26" width="35" height="20" label="-"
				  click="resetButton_clickHandler(event)" chromeColor="#dadada" color="#000000" cornerRadius="2"/>
		<s:Button id="largerButton" x="422" y="-26" width="35" height="20" label="&lt;"
				  click="largerButton_clickHandler(event)" chromeColor="#dadada" color="#000000" cornerRadius="2"/>
		<s:Button id="smallerButton" x="384" y="-26" width="35" height="20" label="&gt;"
				  click="smallerButton_clickHandler(event)" chromeColor="#dadada" color="#000000" cornerRadius="2"/>
		<s:Button id="dragButton" x="346" y="-26" width="35" height="20" label="off"
				  click="dragButton_clickHandler(event)" chromeColor="#dadada" color="#000000" cornerRadius="2"/>
		<s:HSlider x="264" y="-20" width="68" id="alphaSlider" minimum="0" maximum="1" stepSize="0.05" value="1" 
				   change="alphaSlider_changeHandler(event)" chromeColor="#dadada"/>
		<s:Group clipAndEnableScrolling="true" width="100%" height="100%" visible="true" id="geometryBox" 
				 mouseDown="geometryPanel_mouseDownHandler(event)" 
				 mouseMove="geometryPanel_mouseMoveHandler(event)"
				 mouseUp="geometryPanel_mouseUpHandler(event)"
				 x="0" y="0">
			<s:Group id="geometrySubBox" x="0" y="0" width="100%" height="100%">
				<mx:Image id="baseMapImage"/>
				<mx:Image id="workLayer" alpha="1.0" />
				<mx:Image id="annotationLayer" alpha="1.0" />
			</s:Group>
		</s:Group>
	</s:Panel>	
	
	<s:Group x="532" y="167" width="92" height="104" right="15" top="167">
		<s:Rect x="0.5" y="0.5" width="100%" height="100%">
			<s:stroke>
				<s:SolidColorStroke color="0xc8c8c8"/>
			</s:stroke>
			<s:fill>
				<s:SolidColor color="0xdadada"/>
			</s:fill>
		</s:Rect>
		
		<s:Label x="4" y="12" fontWeight="bold" text="Geometry"/>
		<s:RadioButton x="4" y="28" label="SG_Point" groupName="geomGroup" id="pointRadio"/>
		<s:RadioButton x="4" y="52" label="SG_Curve" groupName="geomGroup" id="curveRadio"/>
		<s:RadioButton x="4" y="74" label="SG_Surface" groupName="geomGroup" id="surfaceRadio"/>		
	</s:Group>
	
	<s:Group x="531" y="281" width="92" height="46" right="15" top="281">
		<s:Rect x="0" y="0" width="100%" height="100%">
			<s:stroke>
				<s:SolidColorStroke color="0xc8c8c8"/>
			</s:stroke>
			<s:fill>
				<s:SolidColor color="0xdadada"/>
			</s:fill>
		</s:Rect>
		<s:Label x="6" y="8" fontWeight="bold" text="Association"/>
		<s:Label id="fromToLabel" x="8" y="22" width="35" height="20" text="" verticalAlign="middle"/>
		<s:Label id="multiLabel" x="52" y="26" text="multi"/>
	</s:Group>
	
	<s:Group x="530" y="336" width="92" height="101" right="15" top="336">
		<s:Rect x="0" y="0" width="100%" height="100%">
			<s:stroke>
				<s:SolidColorStroke color="0xc8c8c8"/>
			</s:stroke>
			<s:fill>
				<s:SolidColor color="0xdadada"/>
			</s:fill>
		</s:Rect>
		
		<s:RadioButton x="8" y="7" label="add" id="addGeomButton" groupName="operationGroup" click="addGeomButton_clickHandler(event)"/>
		<s:RadioButton x="8" y="30" label="search" id="searchGeomButton" groupName="operationGroup" click="searchGeomButton_clickHandler(event)"/>
		<s:RadioButton x="8" y="53" label="move" id="moveGeomButton" groupName="operationGroup" click="moveGeomButton_clickHandler(event)" />
		<s:RadioButton x="8" y="75" label="delete" id="deleteGeomButton" groupName="operationGroup" click="deleteGeomButton_clickHandler(event)"/>
	</s:Group>
	
	<s:Group left="21" bottom="7" width="280" height="20">
		<s:Label x="1" y="5" text="X"/>
		<s:Label x="138" y="5" text="Y"/>
		<s:Label x="12" y="0" width="103" id="XLabel" backgroundColor="#DADADA" verticalAlign="middle" height="20"/>
		<s:Label x="148" y="0" id="YLabel" width="113" backgroundColor="#DADADA" verticalAlign="middle" height="20"/>
	</s:Group>
	
	<s:Label x="547" y="16" text="日本語" fontFamily="Osaka" color="#969696" fontSize="11"
			 buttonMode="true" click="text_jp_clickHandler(event)"/>
	<s:Label x="588" y="18" text="English" color="#969696"
			 buttonMode="true" click="text_en_clickHandler(event)"/>
</s:Window>